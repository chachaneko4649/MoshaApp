<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>KAZUさんの模写アプリ_決定版V2</title>
    <style>
        html, body { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; background: #222; font-family: sans-serif; }
        body { display: flex; flex-direction: column; }
        #top-area, #bottom-area { flex: 1; position: relative; overflow: hidden; width: 100%; }
        #top-area { background: #444; border-bottom: 2px solid #000; }
        #bottom-area { background: #fff; touch-action: none; }
        .img-layer { position: absolute; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; pointer-events: none; }
        #preview { max-width: 100%; max-height: 100%; object-fit: contain; }
        canvas { width: 100%; height: 100%; display: block; }
        .controls-top { position: absolute; top: 10px; left: 10px; z-index: 1000; }
        .toolbar { 
            position: absolute; bottom: 25px; left: 10px; right: 10px; 
            z-index: 1000; display: flex; flex-wrap: wrap; gap: 8px; 
            background: rgba(0,0,0,0.85); padding: 12px; border-radius: 12px; 
            justify-content: center; align-items: center; color: white;
        }
        label, button { background: #555; color: white; padding: 8px 12px; border-radius: 6px; font-size: 13px; border: none; cursor: pointer; }
        .active { background: #007bff !important; }
        input[type="range"] { width: 70px; margin: 0 5px; vertical-align: middle; }
    </style>
</head>
<body>

    <div id="top-area">
        <div class="controls-top">
            <label for="file-upload">画像を選択</label>
            <input type="file" id="file-upload" accept="image/*" style="display:none;">
        </div>
        <div id="img-container" style="width:100%; height:100%; transform-origin: 0 0;">
            <div class="img-layer"><img id="preview" src="" alt=""></div>
        </div>
    </div>

    <div id="bottom-area">
        <div class="toolbar">
            <button id="btn-pen" class="active" onclick="setTool('pen')">ペン</button>
            <button id="btn-eraser" onclick="setTool('eraser')">消しゴム</button>
            <button id="btn-move" onclick="setTool('move')">移動/拡大</button>
            <span>太さ:</span>
            <input type="range" id="pen-size" min="1" max="50" value="5">
            <button onclick="undo()">戻る</button>
            <button onclick="redo()">進む</button>
            <button onclick="clearCanvas()" style="background:#d9534f;">消去</button>
        </div>
        <div id="canvas-container" style="width:100%; height:100%; transform-origin: 0 0;">
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const img = document.getElementById('preview');
        const imgContainer = document.getElementById('img-container');
        const canvasContainer = document.getElementById('canvas-container');
        const penSizeInput = document.getElementById('pen-size');

        let tool = 'pen';
        let isDrawing = false;
        let history = [];
        let historyStep = -1;

        let states = {
            top: { scale: 1, x: 0, y: 0, isMoving: false },
            bottom: { scale: 1, x: 0, y: 0, isMoving: false }
        };

        function init() {
            const rect = document.getElementById('bottom-area').getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            // 初回起動時だけ真っ白な状態を保存
            if (history.length === 0) saveHistory();
        }
        window.onload = init;
        window.onresize = init;

        function setTool(t) {
            tool = t;
            document.getElementById('btn-pen').classList.toggle('active', t === 'pen');
            document.getElementById('btn-eraser').classList.toggle('active', t === 'eraser');
            document.getElementById('btn-move').classList.toggle('active', t === 'move');
        }

        let lastX = 0, lastY = 0;
        let touchStartDist = 0;
        let initialScale = 1;

        function getPos(e) {
            const t = e.touches ? e.touches[0] : e;
            return { x: t.clientX, y: t.clientY };
        }

        function startAction(e) {
            if (e.cancelable) e.preventDefault();
            const targetId = e.currentTarget.id === 'top-area' ? 'top' : 'bottom';
            const state = states[targetId];
            const pos = getPos(e);

            if (e.touches && e.touches.length === 2) {
                touchStartDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                initialScale = state.scale;
            } else {
                if (tool === 'move' || targetId === 'top') {
                    state.isMoving = true;
                    lastX = pos.x; lastY = pos.y;
                } else if (targetId === 'bottom') {
                    isDrawing = true;
                    const rect = canvas.getBoundingClientRect();
                    const canvasX = (pos.x - rect.left - states.bottom.x) / states.bottom.scale;
                    const canvasY = (pos.y - rect.top - states.bottom.y) / states.bottom.scale;
                    ctx.beginPath();
                    ctx.moveTo(canvasX, canvasY);
                    // 描き始めの点だけでも打っておく
                    drawAction(e);
                }
            }
        }

        function drawAction(e) {
            const targetId = e.currentTarget.id === 'top-area' ? 'top' : 'bottom';
            const state = states[targetId];
            const container = targetId === 'top' ? imgContainer : canvasContainer;
            const pos = getPos(e);

            if (e.touches && e.touches.length === 2) {
                const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                state.scale = initialScale * (dist / touchStartDist);
            } else {
                if (state.isMoving) {
                    state.x += pos.x - lastX;
                    state.y += pos.y - lastY;
                    lastX = pos.x; lastY = pos.y;
                } else if (isDrawing && targetId === 'bottom') {
                    const rect = canvas.getBoundingClientRect();
                    const canvasX = (pos.x - rect.left - states.bottom.x) / states.bottom.scale;
                    const canvasY = (pos.y - rect.top - states.bottom.y) / states.bottom.scale;
                    
                    ctx.lineWidth = penSizeInput.value; // ここでリアルタイムに太さを反映！
                    ctx.strokeStyle = (tool === 'eraser') ? '#fff' : '#333';
                    ctx.lineTo(canvasX, canvasY);
                    ctx.stroke();
                }
            }
            container.style.transform = `translate(${state.x}px, ${state.y}px) scale(${state.scale})`;
        }

        function stopAction() {
            if (isDrawing) {
                isDrawing = false;
                saveHistory();
            }
            states.top.isMoving = false;
            states.bottom.isMoving = false;
        }

        ['top-area', 'bottom-area'].forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('mousedown', startAction);
            el.addEventListener('mousemove', drawAction);
            el.addEventListener('touchstart', startAction, {passive: false});
            el.addEventListener('touchmove', drawAction, {passive: false});
        });

        window.addEventListener('mouseup', stopAction);
        window.addEventListener('touchend', stopAction);

        // 履歴管理（Undo/Redo）の決定版
        function saveHistory() {
            // もし「戻る」をした後に新しく描き始めたら、それ以降の履歴（Redo分）を消す
            if (historyStep < history.length - 1) {
                history = history.slice(0, historyStep + 1);
            }
            history.push(canvas.toDataURL());
            historyStep++;
        }

        function undo() {
            if (historyStep > 0) {
                historyStep--;
                loadFromHistory();
            }
        }

        function redo() {
            if (historyStep < history.length - 1) {
                historyStep++;
                loadFromHistory();
            }
        }

        function loadFromHistory() {
            const tempImg = new Image();
            tempImg.src = history[historyStep];
            tempImg.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(tempImg, 0, 0);
            };
        }

        function clearCanvas() {
            if(confirm('全部消してもよかですか？')) {
                ctx.clearRect(0,0,canvas.width,canvas.height);
                saveHistory();
            }
        }

        document.getElementById('file-upload').onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    img.src = ev.target.result;
                    img.onload = () => { 
                        states.top = { scale: 1, x: 0, y: 0, isMoving: false }; 
                        imgContainer.style.transform = `translate(0,0) scale(1)`; 
                    };
                };
                reader.readAsDataURL(file);
            }
        };
    </script>
</body>
</html>
